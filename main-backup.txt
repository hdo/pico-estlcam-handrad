#include <stdio.h>
#include <math.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "hardware/irq.h"
#include "hardware/adc.h"

/*
 
Datenframe Modus 1:
Byte 1: 255 (Altlast - muss 255 zurückgeben, sonst ggf. Probleme!)
Byte 2:
Bit 0 = Start / Stopp Taste Programmstart (1 = nicht gedrückt / 0 = gedrückt)
Bit 1 = Start / Stopp Taste Fräsmotor (1 = nicht gedrückt / 0 = gedrückt)
Bit 2 = 1 (sonst ggf. Probleme!)
Bit 3 = "OK" Taste (1 = nicht gedrückt / 0 = gedrückt)
Bit 4 bis 7 = 1 (sonst ggf. Probleme!)
Byte 3: Low Byte Vorschub Poti
Byte 4: High Byte Vorschub Poti
Byte 5: Low Byte Drehzahl Poti
Byte 6: High Byte Drehzahl Poti
Byte 7: Low Byte X Joystick
Byte 8: High Byte X Joystick
Byte 9: Low Byte Y Joystick
Byte 10: High Byte Y Joystick
Byte 11: Low Byte Z Joystick
Byte 12: High Byte Z Joystick
Byte 13: 1 (Modus)
Byte 14: Frame (ständig durchlaufend 0-255)
Byte 15: Prüfsumme (siehe Berechnung der Prüfsumme)
Poti und Joystickstellungen sind 16 Bit Unsigned Integer von 0 bis 65535.
   
 */



#define I2C_PORT i2c0
//#define I2C_ADDR 0b00000100
#define I2C_ADDR 0b0000010


#define READ_SIZE 9
#define WRITE_SIZE 15

#define MODEID_NORMAL    1 
#define MODEID_IDENTIFY  3
#define MODEID_CHALLENGE 4
#define MODEID_SERIAL    5


// define the hardware registers used
volatile uint32_t * const I2C0_DATA_CMD       = (volatile uint32_t * const)(I2C0_BASE + 0x10);
volatile uint32_t * const I2C0_INTR_STAT      = (volatile uint32_t * const)(I2C0_BASE + 0x2c);
volatile uint32_t * const I2C0_INTR_MASK      = (volatile uint32_t * const)(I2C0_BASE + 0x30);
volatile uint32_t * const I2C0_CLR_RD_REQ     = (volatile uint32_t * const)(I2C0_BASE + 0x50);
volatile uint32_t * const I2C0_CLR_STOP_DET   = (volatile uint32_t * const)(I2C0_BASE + 0x60);
volatile uint32_t * const I2C0_CLR_START_DET  = (volatile uint32_t * const)(I2C0_BASE + 0x64);

// Declare the bits in the registers we use
#define I2C_DATA_CMD_FIRST_BYTE  0x00000800
#define I2C_DATA_CMD_DATA        0x000000ff
#define I2C_INTR_STAT_READ_REQ   0x00000020
#define I2C_INTR_STAT_RX_FULL    0x00000004
#define I2C_INTR_STAT_START_DET  (1 << 10)   // bit 10
#define I2C_INTR_MASK_READ_REQ   0x00000020  // bit 5 (1 << 5)
#define I2C_INTR_MASK_RX_FULL    0x00000004
#define I2C_INTR_MASK_START_DET  (1 << 10)   // bit 10

#define I2C_INTR_STAT_STOP_DET  (1 << 9)   
#define I2C_INTR_MASK_STOP_DET  (1 << 9)   



#define GPIO_OK         22  // BLUE
#define GPIO_SPINDLE    21  // YELLOW
#define GPIO_PROG       20  // GREEN

const uint8_t LED_PIN = 25;
const uint8_t IDENT_STRING[] = "Handrad 0001";
const uint8_t SERIAL_STRING[] = "ABCD12345678";
const uint8_t CHALLENGE_VALUE[] = {0x3B, 0x59, 0xE8, 0x2A, 0xE9, 0xB1, 0xBE, 0xD8, 0x00, 0x00, 0x00, 0x00};

uint8_t rx_head = 0;
uint8_t tx_head = 0;
uint8_t rxdata[16];
uint8_t txdata[16];
uint8_t frame_num = 0;

uint8_t mode_selected = 0;
uint8_t crc_checksum = 0;

uint16_t adc_x_raw, adc_y_raw, adc_z_raw, adc_feed_raw, adc_spindle_raw;

uint32_t current_tick()  {
    return time_us_32() / 1000;
}


void printhex(uint8_t *buffer, uint8_t length) {
    for(uint8_t i = 0; i < length; i++) {
        printf("%02X ", buffer[i]);
    }
    printf("\r\n");
}

/*
void calc_checksum() {
    uint8_t checksum = 0;
    for(uint8_t i=0; i < 13; i++) {
        checksum ^= txdata[i];
        checksum++;
    }
    txdata[14] = checksum;    
}
*/



void mode_normal() {
    // reset
    for(uint8_t i; i < 12; i++) {
        txdata[i] = 0;
    }    
    txdata[0] = 0xFF;
    txdata[1] = 0b11110100;
    txdata[12] = MODEID_NORMAL;
}

void mode_identify() {
    for(uint8_t i=0; i < 12; i++) {
        txdata[i] = IDENT_STRING[i];
    }
    txdata[12] = MODEID_IDENTIFY;
}

void mode_challenge() {
    for(uint8_t i=0; i < 12; i++) {
        txdata[i] = CHALLENGE_VALUE[i];
    }    
    txdata[12] = MODEID_CHALLENGE;
}

void mode_serial() {
    for(uint8_t i=0; i < 12; i++) {
        txdata[i] = SERIAL_STRING[i];
    }
    txdata[12] = MODEID_SERIAL;
}


void setup_mock() {
    for(uint8_t i=0; i < sizeof(txdata); i++) {
        txdata[i] = i;
    }
}


void i2c0_irq_handler() {
    // Get interrupt status
    uint32_t status = *I2C0_INTR_STAT;

    // check for start condition
    if (status & I2C_INTR_STAT_START_DET) {
        // reset heads
        tx_head = 0;
        rx_head = 0;
        *I2C0_CLR_START_DET;
        puts("A");
    }

    // check for stop condition
    if (status & I2C_INTR_STAT_STOP_DET) {
        // reset heads
        tx_head = 0;
        rx_head = 0;
        *I2C0_CLR_STOP_DET;
        puts("O");
    }

    // Check to see if we have received data from the I2C master
    if (status & I2C_INTR_STAT_RX_FULL) {
        gpio_put(LED_PIN, 1);

        // Read the data (this will clear the interrupt)
        uint32_t value = *I2C0_DATA_CMD;
        //printf("%02X ", value);

        // Check if this is the 1st byte we have received
        if (value & I2C_DATA_CMD_FIRST_BYTE) {
            // 
            rx_head = 0;
            // If so treat it as the address to use          
        } 

        rxdata[rx_head++] = (uint8_t)(value & I2C_DATA_CMD_DATA);

        if (rx_head == READ_SIZE) {
            printhex(rxdata, READ_SIZE);
            mode_selected = rxdata[0];
            printf("mode: %d \r\n", mode_selected);

            switch(mode_selected) {
                case 1 : mode_normal(); break;
                case 3 : mode_identify(); break;
                case 4 : mode_challenge(); break;
                case 5 : mode_serial(); break;
            }

        }

        if (rx_head > READ_SIZE) {
            rx_head = 0;
            puts("rx ->0");
        }
        gpio_put(LED_PIN, 0);
    }

    // Check to see if the I2C master is requesting data from us
    if (status & I2C_INTR_STAT_READ_REQ) {
        gpio_put(LED_PIN, 1);

        // calc checksum
        if (tx_head == 0) {
            crc_checksum = 0;
        }

        crc_checksum = crc_checksum ^ txdata[tx_head];
        crc_checksum++;        

        // update frame num (byte 14)
        if (tx_head == 13) {
            txdata[13] = frame_num++;

            // set checksum
            txdata[14] = crc_checksum;             
        }

        if (tx_head <= WRITE_SIZE) {
            // Write the data from the current address in RAM
            *I2C0_DATA_CMD = (uint32_t) txdata[tx_head++];
        }
        else {
            tx_head = 0;
            //puts("tx out of bounds");
            puts("tx ->0 \r\n");
        }

        gpio_put(LED_PIN, 0);

        // Clear the interrupt
        *I2C0_CLR_RD_REQ;
    }
}

void init_gpio() {
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);

    gpio_init(GPIO_OK);
    gpio_set_dir(GPIO_OK, GPIO_IN);
    gpio_pull_up(GPIO_OK);

    gpio_init(GPIO_PROG);
    gpio_set_dir(GPIO_PROG, GPIO_IN);
    gpio_pull_up(GPIO_PROG);

    gpio_init(GPIO_SPINDLE);
    gpio_set_dir(GPIO_SPINDLE, GPIO_IN);
    gpio_pull_up(GPIO_SPINDLE);

}

int main() {
    stdio_init_all();

    init_gpio();



    // init ADC
    adc_init();

    // Make sure GPIO is high-impedance, no pullups etc
    adc_gpio_init(26);
    adc_gpio_init(27);
    adc_gpio_init(28);

    // This example will use I2C0 on the default SDA and SCL pins (4, 5 on a Pico)
    i2c_init(I2C_PORT, 10 * 1000);
    i2c_set_slave_mode(I2C_PORT, true, I2C_ADDR);
    
    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);
    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);



    // blinky
    for(int i=0; i < 5; i++) {
        gpio_put(LED_PIN, 0);
        sleep_ms(200);
        gpio_put(LED_PIN, 1);
        sleep_ms(200);
    }

    //setup_mock();
    //mode_normal();
    mode_identify();


    puts("Started ...\n");
    printhex(txdata, 15);


    // Enable the interrupts we want
    *I2C0_INTR_MASK = (I2C_INTR_MASK_READ_REQ | I2C_INTR_MASK_RX_FULL | I2C_INTR_MASK_START_DET | I2C_INTR_MASK_STOP_DET);
    //*I2C0_INTR_MASK = (I2C_INTR_MASK_READ_REQ | I2C_INTR_MASK_RX_FULL);

    // Set up the interrupt handlers
    irq_set_exclusive_handler(I2C0_IRQ, i2c0_irq_handler);
    // Enable I2C interrupts
    irq_set_enabled(I2C0_IRQ, true);

    uint8_t last_mode = 0;

    uint32_t last_trigger = current_tick();

    adc_feed_raw = 32000;
    adc_spindle_raw = 32000;

    uint8_t b1, b2 = 0;

    while (1) {

        /*
        if (last_mode != mode_selected) {
            last_mode == mode_selected;
            switch(mode_selected) {
                case 1 : mode_normal(); break;
                case 3 : mode_identify(); break;
                case 4 : mode_challenge(); break;
                case 5 : mode_serial(); break;
            }
        }
        */

        // read adc values

        
        adc_select_input(0);
        adc_x_raw = adc_read() * 65500/4096;
        adc_select_input(1);
        adc_y_raw = adc_read() * 65500/4096;
        adc_select_input(2);
        adc_z_raw = adc_read() * 65500/4096;

        if (mode_selected == MODEID_NORMAL) {
            txdata[6] = 0xFF & adc_x_raw;
            txdata[7] = adc_x_raw >> 8;
            txdata[8] = 0xFF & adc_y_raw;
            txdata[9] = adc_y_raw >> 8;
            txdata[10] = 0xFF & adc_z_raw;
            txdata[11] = adc_z_raw >> 8;            
        }

        if (gpio_get(GPIO_SPINDLE) == 0)  {
            adc_feed_raw = 0;
            adc_spindle_raw = 0;
            txdata[2] = 0xFF & adc_feed_raw;
            txdata[3] = adc_feed_raw >> 8;
            txdata[4] = 0xFF & adc_spindle_raw;
            txdata[5] = adc_spindle_raw >> 8;
            b1 = 1;
        } 
        else {
            b1 = 0;
        }

        if (gpio_get(GPIO_PROG) == 0)  {
            adc_feed_raw = 65000;
            adc_spindle_raw = 65000;
            txdata[2] = 0xFF & adc_feed_raw;
            txdata[3] = adc_feed_raw >> 8;
            txdata[4] = 0xFF & adc_spindle_raw;
            txdata[5] = adc_spindle_raw >> 8;
            b2 = 1;
        }
        else {
            b2 = 0;
        }

        if (current_tick() - last_trigger > 500) {
            last_trigger = current_tick();
            printf("x: %d    y: %d   z: %d  f:  %d   s: %d   \r\n", adc_x_raw, adc_y_raw, adc_z_raw, adc_feed_raw, adc_spindle_raw);
            if (b1 == 0 && b2 == 0) {
                adc_feed_raw = 32000;
                adc_spindle_raw = 32000;
                txdata[2] = 0xFF & adc_feed_raw;
                txdata[3] = adc_feed_raw >> 8;
                txdata[4] = 0xFF & adc_spindle_raw;
                txdata[5] = adc_spindle_raw >> 8;
            }
        }
    }
}